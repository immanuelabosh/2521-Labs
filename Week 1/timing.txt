 |Input	Initial	Has	Number	AvgTime	AvgTime
Size	Order	Dups	of runs	forusel	forsort
5000	random	no	N	T1sec	T2sec
5000	sorted	no	N	T1sec	T2sec
5000	reverse	no	N	T1sec	T2sec
5000	random	yes	N	T1sec	T2sec
5000	sorted	yes	N	T1sec	T2sec
5000	reverse	yes	N	T1sec	T2sec
10000	random	no	N	T1sec	T2sec
10000	sorted	no	N	T1sec	T2sec
10000	reverse	no	N	T1sec	T2sec
10000	random	yes	N	T1sec	T2sec
10000	sorted	yes	N	T1sec	T2sec
10000	reverse	yes	N	T1sec	T2sec


//commands i use to test each of my number files in a directory 
for i in *; do time ../useIntList < $i > /dev/null; echo $i; done
for i in *; do time sort -n < $i > /dev/null; echo $i; done

//commands i used to generate files
seq 100000 > alreadySortedNoDuplicates
seq 100000 | sort -nr > reverseSortedNoDuplicates
seq 100000 | sort -R > randomOrderNoDuplicates
../randList 100000 | sort -n > alreadySortedDups
../randList 100000 | sort -nr > reverseSortedDups
../randList 100000 > randomOrderDups

//command I used to generate results NOTE i used the real time from time (i.e. time between execution and completion)
//note this command needs to be run in the nums folder
//grep will get the real time, sed grabs the character between m and s and removes the period, awk averages all the times then prints the avg in 2 sigfigs in scientific notation, xarg presents the pipe as a paramater to printf which formats it as a floating point of length 5 with leading 0s and no digits after the decimal point
//useIntList
for i in *; do echo $i; for ((n=0;n<5;n++)) do { time ../useIntList < $i > /dev/null; } done |& grep real | sed -e 's/m\(.*\)s/\1/' -e 's/\.//g' | awk '{ total += $2; count++ } END { printf "%.2g", total/count }' | xargs printf "%05.f\n"; done
//sort -n
for i in *; do echo $i; for ((n=0;n<5;n++)) do { time sort -n < $i > /dev/null; } done |& grep real | sed -e 's/m\(.*\)s/\1/' -e 's/\.//g' | awk '{ total += $2; count++ } END { printf "%.2g", total/count }' | xargs printf "%05.f\n"; done
